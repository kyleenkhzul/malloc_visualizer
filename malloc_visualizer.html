<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Malloc Visualizer</title>
<style>
body {
  font-family: 'Courier New', monospace;
  background: linear-gradient(135deg, #1e1e2f, #111118);
  color: #eee;
  margin: 0;
  padding: 20px;
}

h2 {
  font-size: 2rem;
  text-align: center;
  color: #f0f0f0;
  text-shadow: 1px 1px 6px rgba(0,0,0,0.8);
  margin-bottom: 20px;
}

#controls {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 20px;
}

#controls input[type="number"],
#controls input[type="range"] {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  font-size: 0.95rem;
}

#controls button {
  padding: 6px 14px;
  border-radius: 6px;
  border: none;
  font-weight: bold;
  cursor: pointer;
  background: #3498db;
  color: white;
  transition: all 0.2s ease;
}

#controls button:hover {
  background: #2980b9;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

#speedLabel {
  margin-left: 6px;
  font-weight: bold;
}

#heap {
  display: flex;
  align-items: stretch;
  margin-top: 40px;
  border: 2px solid #555;
  height: 110px;
  overflow-x: auto;
  overflow-y: visible;
  overflow: visible;
  border-radius: 8px;
  background: rgba(0,0,0,0.3);
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  padding: 6px;
}

.block-container {
  display: flex;
  border-right: 2px solid #000;
  position: relative;
  transition: transform 0.25s ease, box-shadow 0.25s ease;
  border-radius: 4px;
  cursor: pointer;
}

.block-container:hover {
  transform: translateY(-4px);
  box-shadow: 0 6px 14px rgba(0,0,0,0.6);
  z-index: 5;
}

.meta, .payload {
  transition: width 0.4s ease, background 0.3s ease;
}

.meta {
  background: #555;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  color: #fff;
  white-space: nowrap;
  padding: 0 4px;
  border-radius: 2px 0 0 2px;
}

.payload {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  white-space: nowrap;
  padding: 0 6px;
  border-radius: 0 2px 2px 0;
}

.allocated {
  background: #3498db;
}

.free {
  background: #e74c3c;
}

/* --- Highlights --- */
.search-highlight { outline: 4px solid yellow; }
.reuse-highlight { outline: 4px solid orange; }
.split-highlight { outline: 4px solid cyan; }
.expand-highlight { outline: 4px solid purple; }
.coalesce-highlight { box-shadow: 0 0 12px 4px lime; }

/* --- Merge/Split Boundaries --- */
.merge-boundary {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 4px;
  background: lime;
  animation: mergeFade 0.6s ease forwards;
}
@keyframes mergeFade { 0% { opacity: 1; } 100% { opacity: 0; } }

.split-border {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 4px;
  background: yellow;
  animation: splitBorderFade 0.5s ease forwards;
}
@keyframes splitBorderFade { 0% { opacity: 0; } 50% { opacity: 1; } 100% { opacity: 0; } }

/* --- Animations --- */
.split-animate { animation: splitFlash 0.6s ease; }
@keyframes splitFlash { 0% { box-shadow: 0 0 0px cyan; } 50% { box-shadow: 0 0 20px cyan; } 100% { box-shadow: 0 0 0px cyan; } }

.coalesce-animate { animation: coalesceFlash 0.6s ease; }
@keyframes coalesceFlash { 0% { box-shadow: 0 0 0px lime; } 50% { box-shadow: 0 0 20px lime; } 100% { box-shadow: 0 0 0px lime; } }

.reuse-animate { animation: reuseFlash 0.6s ease; }
@keyframes reuseFlash { 0% { background-color: orange; } 100% { } }

.allocating { animation: allocateFade 0.6s ease forwards; }
@keyframes allocateFade { 0% { background-color: #e74c3c; } 100% { background-color: #3498db; } }

.tooltip {
  position: absolute;
  bottom: 120%;
  left: 0;
  background: rgba(30,30,30,0.95);
  border: 1px solid #888;
  padding: 6px 8px;
  font-size: 11px;
  white-space: nowrap;
  display: none;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.5);
}

.block-container:hover .tooltip { display: block; }

.head::before { content: "HEAD"; position: absolute; top: -22px; left: 0; color: gold; font-size: 12px; }
.tail::after { content: "TAIL"; position: absolute; top: -22px; right: 0; color: violet; font-size: 12px; }

#info {
  margin-top: 20px;
  text-align: center;
  font-size: 0.95rem;
  color: #ccc;
}

#toast {
  position: fixed;
  top: 30px;
  left: 50%;
  transform: translateX(-50%) translateY(-20px);
  color: white;
  padding: 14px 22px;
  border-radius: 10px;
  font-weight: bold;
  box-shadow: 0 10px 30px rgba(0,0,0,0.4);
  opacity: 0;
  pointer-events: none;
  transition: all 0.3s ease;
  z-index: 1000;
}

#toast.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0px);
}
.toast-error {
  background: #ff4d4d;
}

.toast-info {
  background: #3498db;
}

.description {
  max-width: 900px;
  margin: 20px auto 30px auto;
  padding: 20px 25px;
  background: rgba(255,255,255,0.05);
  border-radius: 14px;
  color: #ddd;
  line-height: 1.6;
  font-size: 15px;
}

.description h3 {
  margin-top: 15px;
  margin-bottom: 8px;
  color: #ffffff;
  font-size: 16px;
}

.description ul {
  padding-left: 20px;
  margin: 0;
}

.description li {
  margin-bottom: 4px;
}
</style>
</head>
<body>

<h2>Malloc Visualizer</h2>
<div class="description">
  <p>
    This interactive heap visualizer demonstrates how a dynamic memory allocator works.
    You can allocate, free, and reallocate memory while watching how blocks split,
    coalesce, and are traversed using a first-fit strategy.
  </p>

  <p>
    <strong>Interaction:</strong> Hover over any block to view
    its address and size. Clicking a block automatically copies its
    <strong>payload pointer</strong> into the pointer field.
    All <code>free</code> and <code>realloc</code> operations must use the
    payload pointer — metadata addresses are internal and not visible to the user.
  </p>

  <h3>Key Assumptions</h3>
  <ul>
    <li>All allocations are aligned to 16 bytes</li>
    <li>Metadata size is 16 bytes per block</li>
    <li>Malloc uses a first-fit strategy</li>
    <li>Blocks form a doubly linked list with boundary tags</li>
    <li>An explicit free list is maintained, with most recently freed block being the head</li>
    <li>Splitting and coalescing are supported</li>
  </ul>
</div>

<div id="controls">
  Size: <input id="sizeInput" type="number" value="32">
  <button onclick="malloc()">malloc</button>
  Ptr: <input id="ptrInput" type="number">
  <button onclick="freeBlock()">free</button>
  <button onclick="reallocBlock()">realloc</button>
</div>

<div class="control-group">
  <label for="speedInput" class="slider-label">
    Animation Speed (ms per step)
  </label>
  <input 
    type="range" 
    id="speedInput" 
    min="50" 
    max="1000" 
    step="50" 
    value="600"
  />
  <span id="speedValue">600 ms</span>
</div>


<div id="heap"></div>

<div id="info"></div>

<script>
const speedSlider = document.getElementById("speedInput");
const speedValue = document.getElementById("speedValue");

speedValue.innerText = speedSlider.value + " ms";

speedSlider.addEventListener("input", () => {
  speedValue.innerText = speedSlider.value + " ms";
});

function showToast(message, type = "error") {
  const toast = document.getElementById("toast");

  toast.innerText = message;
  toast.className = ""; // reset classes
  toast.classList.add("show");

  if (type === "error") toast.classList.add("toast-error");
  if (type === "info") toast.classList.add("toast-info");

  setTimeout(() => {
    toast.classList.remove("show");
  }, 2500);
}

function showError(message) {
  showToast(message, "error");
}

function showInfo(message) {
  showToast(message, "info");
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

const METADATA_SIZE = 16;
const ALIGNMENT = 16;

function align16(x) {
  return (x + 15) & ~15;
}

class Block {
  constructor(start, size, free=false) {
    this.start = start;
    this.size = size;
    this.free = free;

    this.next_phys = null;
    this.prev_phys = null;

    this.next_free = null;
    this.prev_free = null;
  }

  payloadStart() {
    return this.start + METADATA_SIZE;
  }

  totalSize() {
    return METADATA_SIZE + this.size;
  }
}

class Heap {
  constructor() {
    this.head = null;
    this.tail = null;
    this.free_head = null;
    this.heap_size = 0;
  }

  requestSpace(size) {
    let total = align16(size + METADATA_SIZE);
    let block = new Block(this.heap_size, size, false);
    this.heap_size += total;

    block.prev_phys = this.tail;
    if (this.tail) this.tail.next_phys = block;
    else this.head = block;

    this.tail = block;
    return block;
  }

  addToFree(block) {
    block.free = true;
    block.next_free = this.free_head;
    block.prev_free = null;
    if (this.free_head) this.free_head.prev_free = block;
    this.free_head = block;
  }

  removeFromFree(block) {
    if (block.prev_free) block.prev_free.next_free = block.next_free;
    else this.free_head = block.next_free;

    if (block.next_free) block.next_free.prev_free = block.prev_free;

    block.next_free = block.prev_free = null;
    block.free = false;
  }

  split(block, size) {
    if (block.size < size + METADATA_SIZE + 16) return;

    block.justSplit = true;

    let newStart = block.payloadStart() + size - METADATA_SIZE;
    let newSize = block.size - size - METADATA_SIZE;

    let newBlock = new Block(newStart, newSize, true);
    newBlock.justCreated = true;

    newBlock.next_phys = block.next_phys;
    newBlock.prev_phys = block;

    if (newBlock.next_phys)
      newBlock.next_phys.prev_phys = newBlock;
    else
      this.tail = newBlock;

    block.size = size;
    block.next_phys = newBlock;

    this.addToFree(newBlock);
  }

  coalesce(block) {
    let merged = false;
    if (block.next_phys && block.next_phys.free) {
      merged = true;
      let next = block.next_phys;
      this.removeFromFree(next);
      block.size += METADATA_SIZE + next.size;
      block.next_phys = next.next_phys;
      if (next.next_phys)
        next.next_phys.prev_phys = block;
      else
        this.tail = block;
    }

    if (block.prev_phys && block.prev_phys.free) {
      merged = true;
      let prev = block.prev_phys;
      this.removeFromFree(prev);
      prev.size += METADATA_SIZE + block.size;
      prev.next_phys = block.next_phys;
      if (block.next_phys)
        block.next_phys.prev_phys = prev;
      else
        this.tail = prev;
      block = prev;
    }

    if (merged) block.justCoalesced = true;

    this.addToFree(block);
  }

  getBlock(ptr) {
    let curr = this.head;
    while (curr) {
      if (curr.payloadStart() === ptr) return curr;
      curr = curr.next_phys;
    }
    return null;
  }
}

const heap = new Heap();

function render() {
  const container = document.getElementById("heap");
  container.innerHTML = "";

  const MIN_WIDTH = 16;
  const META_WIDTH = 16;
  const scaleFactor = META_WIDTH / METADATA_SIZE;

  let curr = heap.head;

  while (curr) {
    const blockContainer = document.createElement("div");
    blockContainer.className = "block-container";
    const block = curr; 

    blockContainer.addEventListener("click", (e) => {
      e.stopPropagation(); // prevent bubbling issues

      const ptr = block.payloadStart();
      document.getElementById("ptrInput").value = ptr;

    });

    if (curr.mergeLeft) {
      const boundary = document.createElement("div");
      boundary.className = "merge-boundary";
      boundary.style.left = "0px";
      blockContainer.appendChild(boundary);
      curr.mergeLeft = false;
    }

    if (curr.mergeRight) {
      const boundary = document.createElement("div");
      boundary.className = "merge-boundary";
      boundary.style.right = "0px";
      blockContainer.appendChild(boundary);
      curr.mergeRight = false;
    }

    if (curr.drawSplit) {
      const splitLine = document.createElement("div");
      splitLine.className = "split-border";

      const META_WIDTH = 16;
      const scaleFactor = META_WIDTH / METADATA_SIZE;

      const splitPosition = META_WIDTH + curr.drawSplit * scaleFactor;
      splitLine.style.left = splitPosition + "px";

      blockContainer.appendChild(splitLine);

      curr.drawSplit = null;
    }

    if (curr.highlight === "search")
      blockContainer.classList.add("search-highlight");

    if (curr.highlight === "reuse")
      blockContainer.classList.add("reuse-highlight");

    if (curr.highlight === "split")
      blockContainer.classList.add("split-highlight");

    if (curr.highlight === "expand")
      blockContainer.classList.add("expand-highlight");

    curr.highlight = null;

    if (curr.justSplit) {
      blockContainer.classList.add("split-animate");
      curr.justSplit = false;
    }

    if (curr.justCoalesced) {
      blockContainer.classList.add("coalesce-animate");
      curr.justCoalesced = false;
    }

    if (curr.justCreated) {
      blockContainer.classList.add("reuse-animate");
      curr.justCreated = false;
    }

    if (curr === heap.head) blockContainer.classList.add("head");
    if (curr === heap.tail) blockContainer.classList.add("tail");

    // --- Tooltip ---
    const tooltip = document.createElement("div");
    tooltip.className = "tooltip";
    tooltip.innerHTML =
      `Metadata Ptr: ${curr.start}<br>` +
      `Payload Ptr: ${curr.payloadStart()}<br>` +
      `Total Size: ${curr.totalSize()} bytes`;

    blockContainer.appendChild(tooltip);

    // --- Metadata ---
    const metaDiv = document.createElement("div");
    metaDiv.className = "meta";
    metaDiv.style.width = META_WIDTH + "px";
    metaDiv.innerText = "M";

    // --- Payload ---
    const payloadDiv = document.createElement("div");
    payloadDiv.className =
      "payload " + (curr.free ? "free" : "allocated");

    if (curr.allocating) {
      payloadDiv.classList.remove("allocated");
      payloadDiv.classList.add("allocating");
    }
    
    let payloadWidth = Math.max(curr.size * scaleFactor, MIN_WIDTH);
    payloadDiv.style.width = payloadWidth + "px";
    payloadDiv.innerText = curr.size;

    blockContainer.appendChild(metaDiv);
    blockContainer.appendChild(payloadDiv);
    container.appendChild(blockContainer);

    curr = curr.next_phys;
  }

  document.getElementById("info").innerHTML =
    "Heap size: " + heap.heap_size +
    "<br>Free list: " + getFreeList();
}

async function animatedFindFree(size, speed) {
  let curr = heap.free_head;
  while (curr) {
    curr.highlight = "search";  // yellow outline for "checking"
    render();
    await sleep(speed);

    if (curr.size >= size) {
      return curr;
    }

    curr.highlight = null;  // remove highlight after checking
    curr = curr.next_free;
  }
  return null;
}

async function malloc() {
  let requestedSize = parseInt(document.getElementById("sizeInput").value);
  let speed = parseInt(document.getElementById("speedInput").value);

  if (!requestedSize || requestedSize <= 0) {
    showError("malloc size must be positive.");
    return;
  }

  size = align16(requestedSize);

  if (size != requestedSize) {
    showInfo(`${requestedSize} aligned to ${size}`);
  }

  let block = await animatedFindFree(size, speed);

  if (block) {

    heap.removeFromFree(block);

    // Only animate if a split will happen
    if (block.size >= size + METADATA_SIZE + 16) {

      // Highlight block
      block.highlight = "split";
      render();
      await sleep(speed);

      // Draw split boundary
      block.drawSplit = size;
      render();
      await sleep(speed);

      // Perform logical split
      heap.split(block, size);
      render();
      await sleep(speed);

      // Animate allocation color transition
      block.allocating = true;
      render();
      await sleep(speed);

      block.allocating = false;

    } else {
      // No split: immediate allocation (no lag)
      block.free = false;
      render();
    }

    const ptr = block.payloadStart();
    document.getElementById("ptrInput").value = ptr;
    return;
  }

  // Heap expansion case (no artificial delay)
  block = heap.requestSpace(size);
  render();

  const ptr = block.payloadStart();
  document.getElementById("ptrInput").value = ptr;
}

function getFreeList() {
  let curr = heap.free_head;
  let arr = [];
  while (curr) {
    arr.push(curr.start);
    curr = curr.next_free;
  }
  return arr.join(" → ");
}

async function animatedFree(ptr, speed) {
  const block = heap.getBlock(ptr);
  if (!block) {
    showError("Invalid free: pointer not allocated.");
    return;
  }

  if (block.free) {
    showError("Double free detected.");
    return;
  }

  const prev = block.prev_phys;
  const next = block.next_phys;

  const canMergePrev = prev && prev.free;
  const canMergeNext = next && next.free;

  // Mark block free immediately (so color updates)
  block.free = true;

  // If no coalescing, instant free
  if (!canMergePrev && !canMergeNext) {
    heap.addToFree(block);
    render();
    return;
  }

  // Highlight this block
  block.highlight = "split"; // reuse cyan outline for now
  render();
  await sleep(speed);

  if (canMergePrev) prev.highlight = "split";
  if (canMergeNext) next.highlight = "split";

  render();
  await sleep(speed);

  // Show boundary fade
  if (canMergePrev) prev.mergeRight = true;
  if (canMergeNext) block.mergeRight = true;

  render();
  await sleep(speed);

  // Perform actual logical coalesce
  heap.coalesce(block);

  render();
}

async function freeBlock() {
  const ptr = parseInt(document.getElementById("ptrInput").value);
  const speed = parseInt(document.getElementById("speedInput").value);
  await animatedFree(ptr, speed);
}

async function reallocBlock() {
  const ptr = parseInt(document.getElementById("ptrInput").value);
  const size = parseInt(document.getElementById("sizeInput").value);
  const speed = parseInt(document.getElementById("speedInput").value);

  if (!ptr) {
    // realloc with NULL ptr is just malloc
    const newPtr = await malloc();
    document.getElementById("ptrInput").value = newPtr;
    return;
  }

  if (size === 0) {
    // realloc to 0 is free
    await animatedFree(ptr, speed);
    document.getElementById("ptrInput").value = "";
    return;
  }
  else if (size < 0){
    showError("realloc size cannot be negative.");
    return;
  }

  const block = heap.getBlock(ptr);
  if (!block) {
    showError("Invalid realloc: pointer not allocated.");
    return;
  }
  const alignedSize = align16(size);
  if (alignedSize !== size) {
    showInfo(`${size} aligned to ${alignedSize}`);
  }

  // Case 1: shrinking
  if (alignedSize <= block.size) {
    if (block.size >= alignedSize + METADATA_SIZE + 16) {
      block.highlight = "split";
      render();
      await sleep(speed);

      // Split visually
      block.drawSplit = alignedSize;
      render();
      await sleep(speed);

      heap.split(block, alignedSize);

      // Animate allocation color
      block.allocating = true;
      render();
      await sleep(speed);
      block.allocating = false;
    }
    return;
  }

  // Case 2: try to expand into next free block
  if (block.next_phys && block.next_phys.free &&
      block.size + METADATA_SIZE + block.next_phys.size >= alignedSize) {
    const next = block.next_phys;
    next.highlight = "coalesce";
    render();
    await sleep(speed);

    heap.removeFromFree(next);
    block.size += METADATA_SIZE + next.size;
    block.next_phys = next.next_phys;
    if (next.next_phys) next.next_phys.prev_phys = block;
    else heap.tail = block;

    // Split if now too large
    if (block.size >= alignedSize + METADATA_SIZE + 16) {
      block.highlight = "split";
      render();
      await sleep(speed);

      block.drawSplit = alignedSize;
      render();
      await sleep(speed);

      heap.split(block, alignedSize);

      block.allocating = true;
      render();
      await sleep(speed);
      block.allocating = false;
    }

    return;
  }

  // Case 3: must allocate new block and free old one
  const newPtr = await malloc();
  await animatedFree(ptr, speed);

  document.getElementById("ptrInput").value = newPtr;
}

render();
</script>
<div id="toast"></div>
</body>
</html>