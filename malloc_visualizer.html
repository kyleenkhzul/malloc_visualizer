<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Malloc Visualizer</title>
<style>
body {
  font-family: monospace;
  background: #111;
  color: white;
}

#heap {
  display: flex;
  align-items: stretch;
  margin-top: 40px;
  border: 3px solid #666;
  height: 110px;
  overflow-x: auto;
  overflow-y: visible;
  overflow: visible;
}

.block-container {
  display: flex;
  border-right: 3px solid #000; /* only between blocks */
  position: relative;
}

.meta {
  background: #555;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  color: white;
  white-space: nowrap;
  padding: 0 4px;
}

.payload {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  white-space: nowrap;
  padding: 0 6px;
}

.allocated {
  background: #3498db;
}

.free {
  background: #e74c3c;
}

.head::before {
  content: "HEAD";
  position: absolute;
  top: -20px;
  left: 0;
  color: gold;
  font-size: 12px;
}

.tail::after {
  content: "TAIL";
  position: absolute;
  top: -20px;
  right: 0;
  color: violet;
  font-size: 12px;
}

#info {
  margin-top: 20px;
}

.block-container {
  display: flex;
  border-right: 3px solid #000;
  position: relative;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.block-container:hover {
  transform: translateY(-4px);
  box-shadow: 0 6px 14px rgba(0,0,0,0.6);
  z-index: 5;
}

.tooltip {
  position: absolute;
  bottom: 120%;
  left: 0;
  background: #222;
  border: 1px solid #888;
  padding: 6px 8px;
  font-size: 11px;
  white-space: nowrap;
  display: none;
}

.block-container:hover .tooltip {
  display: block;
}

.block-container {
  display: flex;
  border-right: 3px solid #000;
  position: relative;
  transition: transform 0.25s ease;
}

.meta, .payload {
  transition: width 0.4s ease, background 0.3s ease;
}

/* Split highlight */
.split-animate {
  animation: splitFlash 0.6s ease;
}

@keyframes splitFlash {
  0% { box-shadow: 0 0 0px yellow; }
  50% { box-shadow: 0 0 20px yellow; }
  100% { box-shadow: 0 0 0px yellow; }
}

/* Coalesce highlight */
.coalesce-animate {
  animation: coalesceFlash 0.6s ease;
}

@keyframes coalesceFlash {
  0% { box-shadow: 0 0 0px lime; }
  50% { box-shadow: 0 0 20px lime; }
  100% { box-shadow: 0 0 0px lime; }
}

/* Reuse highlight */
.reuse-animate {
  animation: reuseFlash 0.6s ease;
}

@keyframes reuseFlash {
  0% { background-color: orange; }
  100% { }
}

.search-highlight {
  outline: 4px solid yellow;
}

.reuse-highlight {
  outline: 4px solid orange;
}

.split-highlight {
  outline: 4px solid cyan;
}

.expand-highlight {
  outline: 4px solid purple;
}

.allocating {
  animation: allocateFade 0.6s ease forwards;
}

@keyframes allocateFade {
  0% {
    background-color: #e74c3c; /* start red (free) */
  }
  100% {
    background-color: #3498db; /* end blue (allocated) */
  }
}

.split-border {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 4px;
  background: yellow;
  animation: splitBorderFade 0.5s ease forwards;
}

@keyframes splitBorderFade {
  0% { opacity: 0; }
  50% { opacity: 1; }
  100% { opacity: 0; }
}

.coalesce-highlight {
  box-shadow: 0 0 12px 4px orange;
}

.merge-boundary {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 4px;
  background: lime;
  animation: mergeFade 0.6s ease forwards;
}

@keyframes mergeFade {
  0% { opacity: 1; }
  100% { opacity: 0; }
}

.expanding {
  transition: width 0.6s ease;
}
</style>
</head>
<body>

<h2>Malloc Visualizer</h2>

<div id="controls">
  Size: <input id="sizeInput" type="number" value="32">
  <button onclick="malloc()">malloc</button>
  Ptr: <input id="ptrInput" type="number">
  <button onclick="freeBlock()">free</button>
  <button onclick="reallocBlock()">realloc</button>
</div>

<input id="speedInput" type="range" min="100" max="2000" value="600">
<span id="speedLabel">600ms</span>

<div id="heap"></div>

<div id="info"></div>

<script>
const METADATA_SIZE = 16;
const ALIGNMENT = 16;

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

document.getElementById("speedInput").oninput = function () {
  document.getElementById("speedLabel").innerText = this.value + "ms";
};

function align16(x) {
  return (x + 15) & ~15;
}

class Block {
  constructor(start, size, free=false) {
    this.start = start;
    this.size = size;
    this.free = free;

    this.next_phys = null;
    this.prev_phys = null;

    this.next_free = null;
    this.prev_free = null;
  }

  payloadStart() {
    return this.start + METADATA_SIZE;
  }

  totalSize() {
    return METADATA_SIZE + this.size;
  }
}

class Heap {
  constructor() {
    this.head = null;
    this.tail = null;
    this.free_head = null;
    this.heap_size = 0;
  }

  requestSpace(size) {
    let total = align16(size + METADATA_SIZE);
    let block = new Block(this.heap_size, size, false);
    this.heap_size += total;

    block.prev_phys = this.tail;
    if (this.tail) this.tail.next_phys = block;
    else this.head = block;

    this.tail = block;
    return block;
  }

  addToFree(block) {
    block.free = true;
    block.next_free = this.free_head;
    block.prev_free = null;
    if (this.free_head) this.free_head.prev_free = block;
    this.free_head = block;
  }

  removeFromFree(block) {
    if (block.prev_free) block.prev_free.next_free = block.next_free;
    else this.free_head = block.next_free;

    if (block.next_free) block.next_free.prev_free = block.prev_free;

    block.next_free = block.prev_free = null;
    block.free = false;
  }

  // findFree(size) {
  //   let curr = this.free_head;
  //   while (curr) {
  //     if (curr.size >= size) return curr;
  //     curr = curr.next_free;
  //   }
  //   return null;
  // }

  split(block, size) {
    if (block.size < size + METADATA_SIZE + 16) return;

    block.justSplit = true;

    let newStart = block.payloadStart() + size - METADATA_SIZE;
    let newSize = block.size - size - METADATA_SIZE;

    let newBlock = new Block(newStart, newSize, true);
    newBlock.justCreated = true;

    newBlock.next_phys = block.next_phys;
    newBlock.prev_phys = block;

    if (newBlock.next_phys)
      newBlock.next_phys.prev_phys = newBlock;
    else
      this.tail = newBlock;

    block.size = size;
    block.next_phys = newBlock;

    this.addToFree(newBlock);
  }

  coalesce(block) {
    let merged = false;
    if (block.next_phys && block.next_phys.free) {
      merged = true;
      let next = block.next_phys;
      this.removeFromFree(next);
      block.size += METADATA_SIZE + next.size;
      block.next_phys = next.next_phys;
      if (next.next_phys)
        next.next_phys.prev_phys = block;
      else
        this.tail = block;
    }

    if (block.prev_phys && block.prev_phys.free) {
      merged = true;
      let prev = block.prev_phys;
      this.removeFromFree(prev);
      prev.size += METADATA_SIZE + block.size;
      prev.next_phys = block.next_phys;
      if (block.next_phys)
        block.next_phys.prev_phys = prev;
      else
        this.tail = prev;
      block = prev;
    }

    if (merged) block.justCoalesced = true;

    this.addToFree(block);
  }

  // malloc(size) {
  //   if (size === 0) return null;
  //   size = align16(size);

  //   let block = this.findFree(size);

  //   if (block) {
  //     this.removeFromFree(block);
  //     this.split(block, size);
  //   } else {
  //     block = this.requestSpace(size);
  //   }

  //   return block.payloadStart();
  // }

  // free(ptr) {
  //   let block = this.getBlock(ptr);
  //   if (!block) return;
  //   this.coalesce(block);
  // }

  // realloc(ptr, size) {
  //   if (!ptr) return this.malloc(size);
  //   if (size === 0) {
  //     this.free(ptr);
  //     return null;
  //   }

  //   let block = this.getBlock(ptr);
  //   size = align16(size);

  //   if (size <= block.size) {
  //     this.split(block, size);
  //     return ptr;
  //   }

  //   if (block.next_phys && block.next_phys.free &&
  //       block.size + METADATA_SIZE + block.next_phys.size >= size) {
  //     let next = block.next_phys;
  //     this.removeFromFree(next);
  //     block.size += METADATA_SIZE + next.size;
  //     block.next_phys = next.next_phys;
  //     if (next.next_phys)
  //       next.next_phys.prev_phys = block;
  //     else
  //       this.tail = block;

  //     this.split(block, size);
  //     return ptr;
  //   }

  //   let newPtr = this.malloc(size);
  //   this.free(ptr);
  //   return newPtr;
  // }

  getBlock(ptr) {
    let curr = this.head;
    while (curr) {
      if (curr.payloadStart() === ptr) return curr;
      curr = curr.next_phys;
    }
    return null;
  }
}

async function malloc() {
    let size = parseInt(document.getElementById("sizeInput").value);
    let speed = parseInt(document.getElementById("speedInput").value);

    let ptr = await animatedMalloc(size, speed);
    document.getElementById("ptrInput").value = ptr;
}

async function animatedMalloc(size, speed) {
  size = align16(size);

  let block = await animatedFindFree(size, speed);

  if (block) {

    heap.removeFromFree(block);

    // ðŸš€ Only animate if a split will happen
    if (block.size >= size + METADATA_SIZE + 16) {

      // Highlight block
      block.highlight = "split";
      render();
      await sleep(speed);

      // Draw split boundary
      block.drawSplit = size;
      render();
      await sleep(speed);

      // Perform logical split
      heap.split(block, size);
      render();
      await sleep(speed);

      // Animate allocation color transition
      block.allocating = true;
      render();
      await sleep(speed);

      block.allocating = false;

    } else {
      // No split: just mark allocated and render immediately
      block.free = false;
      render();
    }

    return block.payloadStart();
  }

  // Heap expansion case
  // No need to delay unless we want expansion animation

  block = heap.requestSpace(size);

  render(); // Immediate render, no delay

  return block.payloadStart();
}

async function animatedFindFree(size, speed) {
  let curr = heap.free_head;
  while (curr) {
    curr.highlight = "search";  // yellow outline for "checking"
    render();
    await sleep(speed);

    if (curr.size >= size) {
      return curr;
    }

    curr.highlight = null;  // remove highlight after checking
    curr = curr.next_free;
  }
  return null;
}

const heap = new Heap();

function render() {
  const container = document.getElementById("heap");
  container.innerHTML = "";

  const MIN_WIDTH = 16;
  const META_WIDTH = 16;
  const scaleFactor = META_WIDTH / METADATA_SIZE;

  let curr = heap.head;

  while (curr) {
    const blockContainer = document.createElement("div");
    blockContainer.className = "block-container";

    if (curr.mergeLeft) {
      const boundary = document.createElement("div");
      boundary.className = "merge-boundary";
      boundary.style.left = "0px";
      blockContainer.appendChild(boundary);
      curr.mergeLeft = false;
    }

    if (curr.mergeRight) {
      const boundary = document.createElement("div");
      boundary.className = "merge-boundary";
      boundary.style.right = "0px";
      blockContainer.appendChild(boundary);
      curr.mergeRight = false;
    }

    if (curr.drawSplit) {
      const splitLine = document.createElement("div");
      splitLine.className = "split-border";

      const META_WIDTH = 16;
      const scaleFactor = META_WIDTH / METADATA_SIZE;

      const splitPosition = META_WIDTH + curr.drawSplit * scaleFactor;
      splitLine.style.left = splitPosition + "px";

      blockContainer.appendChild(splitLine);

      curr.drawSplit = null;
    }

    if (curr.highlight === "search")
      blockContainer.classList.add("search-highlight");

    if (curr.highlight === "reuse")
      blockContainer.classList.add("reuse-highlight");

    if (curr.highlight === "split")
      blockContainer.classList.add("split-highlight");

    if (curr.highlight === "expand")
      blockContainer.classList.add("expand-highlight");

    curr.highlight = null;

    if (curr.justSplit) {
      blockContainer.classList.add("split-animate");
      curr.justSplit = false;
    }

    if (curr.justCoalesced) {
      blockContainer.classList.add("coalesce-animate");
      curr.justCoalesced = false;
    }

    if (curr.justCreated) {
      blockContainer.classList.add("reuse-animate");
      curr.justCreated = false;
    }

    if (curr === heap.head) blockContainer.classList.add("head");
    if (curr === heap.tail) blockContainer.classList.add("tail");

    // --- Tooltip ---
    const tooltip = document.createElement("div");
    tooltip.className = "tooltip";
    tooltip.innerHTML =
      `Metadata Ptr: ${curr.start}<br>` +
      `Payload Ptr: ${curr.payloadStart()}<br>` +
      `Total Size: ${curr.totalSize()} bytes`;

    blockContainer.appendChild(tooltip);

    // --- Metadata ---
    const metaDiv = document.createElement("div");
    metaDiv.className = "meta";
    metaDiv.style.width = META_WIDTH + "px";
    metaDiv.innerText = "M";

    // --- Payload ---
    const payloadDiv = document.createElement("div");
    payloadDiv.className =
      "payload " + (curr.free ? "free" : "allocated");

    if (curr.allocating) {
      payloadDiv.classList.remove("allocated");
      payloadDiv.classList.add("allocating");
    }
    
    let payloadWidth = Math.max(curr.size * scaleFactor, MIN_WIDTH);
    payloadDiv.style.width = payloadWidth + "px";
    payloadDiv.innerText = curr.size;

    blockContainer.appendChild(metaDiv);
    blockContainer.appendChild(payloadDiv);
    container.appendChild(blockContainer);

    curr = curr.next_phys;
  }

  document.getElementById("info").innerHTML =
    "Heap size: " + heap.heap_size +
    "<br>Free list: " + getFreeList();
}

function getFreeList() {
  let curr = heap.free_head;
  let arr = [];
  while (curr) {
    arr.push(curr.start);
    curr = curr.next_free;
  }
  return arr.join(" â†’ ");
}

// function malloc() {
//   let size = parseInt(document.getElementById("sizeInput").value);
//   let ptr = heap.malloc(size);
//   render();
//   document.getElementById("ptrInput").value = ptr;
// }

// function freeBlock() {
//   let ptr = parseInt(document.getElementById("ptrInput").value);
//   heap.free(ptr);
//   render();
// }
async function animatedFree(ptr, speed) {
  const block = heap.getBlock(ptr);   // âœ… correct function
  if (!block) return;

  const prev = block.prev_phys;       // âœ… correct fields
  const next = block.next_phys;

  const canMergePrev = prev && prev.free;
  const canMergeNext = next && next.free;

  // Mark block free immediately (so color updates)
  block.free = true;

  // âš¡ No coalescing â†’ instant
  if (!canMergePrev && !canMergeNext) {
    heap.addToFree(block);
    render();
    return;
  }

  // Highlight this block
  block.highlight = "split"; // reuse cyan outline for now
  render();
  await sleep(speed);

  if (canMergePrev) prev.highlight = "split";
  if (canMergeNext) next.highlight = "split";

  render();
  await sleep(speed);

  // Show boundary fade
  if (canMergePrev) prev.mergeRight = true;
  if (canMergeNext) block.mergeRight = true;

  render();
  await sleep(speed);

  // Perform actual logical coalesce
  heap.coalesce(block);

  render();
}

async function freeBlock() {
  const ptr = parseInt(document.getElementById("ptrInput").value);
  const speed = parseInt(document.getElementById("speedInput").value);
  await animatedFree(ptr, speed);
}

// function reallocBlock() {
//   let ptr = parseInt(document.getElementById("ptrInput").value);
//   let size = parseInt(document.getElementById("sizeInput").value);
//   let newPtr = heap.realloc(ptr, size);
//   render();
//   document.getElementById("ptrInput").value = newPtr;
// }

async function reallocBlock() {
  const ptr = parseInt(document.getElementById("ptrInput").value);
  const size = parseInt(document.getElementById("sizeInput").value);
  const speed = parseInt(document.getElementById("speedInput").value);

  if (!ptr) {
    // realloc with NULL ptr â†’ just malloc
    const newPtr = await animatedMalloc(size, speed);
    document.getElementById("ptrInput").value = newPtr;
    return;
  }

  if (size === 0) {
    // realloc to 0 â†’ free
    await animatedFree(ptr, speed);
    document.getElementById("ptrInput").value = "";
    return;
  }

  const block = heap.getBlock(ptr);
  const alignedSize = align16(size);

  // Case 1: shrinking
  if (alignedSize <= block.size) {
    if (block.size >= alignedSize + METADATA_SIZE + 16) {
      block.highlight = "split";
      render();
      await sleep(speed);

      // Split visually
      block.drawSplit = alignedSize;
      render();
      await sleep(speed);

      heap.split(block, alignedSize);

      // Animate allocation color
      block.allocating = true;
      render();
      await sleep(speed);
      block.allocating = false;
    }
    return;
  }

  // Case 2: try to expand into next free block
  if (block.next_phys && block.next_phys.free &&
      block.size + METADATA_SIZE + block.next_phys.size >= alignedSize) {
    const next = block.next_phys;
    next.highlight = "coalesce";
    render();
    await sleep(speed);

    heap.removeFromFree(next);
    block.size += METADATA_SIZE + next.size;
    block.next_phys = next.next_phys;
    if (next.next_phys) next.next_phys.prev_phys = block;
    else heap.tail = block;

    // Split if now too large
    if (block.size >= alignedSize + METADATA_SIZE + 16) {
      block.highlight = "split";
      render();
      await sleep(speed);

      block.drawSplit = alignedSize;
      render();
      await sleep(speed);

      heap.split(block, alignedSize);

      block.allocating = true;
      render();
      await sleep(speed);
      block.allocating = false;
    }

    return;
  }

  // Case 3: must allocate new block and free old one
  const newPtr = await animatedMalloc(size, speed);
  await animatedFree(ptr, speed);

  document.getElementById("ptrInput").value = newPtr;
}

render();
</script>
</body>
</html>